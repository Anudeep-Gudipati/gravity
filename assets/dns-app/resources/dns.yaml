apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: coredns
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default'
    seccomp.security.alpha.kubernetes.io/defaultProfileName:  'docker/default'
spec:
  privileged: false
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  allowedCapabilities:
  - NET_BIND_SERVICE
  volumes:
  - '*'
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: coredns
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:coredns
rules:
- apiGroups:
  - ""
  resources:
  - endpoints
  - services
  - pods
  - namespaces
  verbs:
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
- apiGroups:
  - policy
  resources:
  - podsecuritypolicies
  verbs:
  - use
  resourceNames:
  - coredns
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:coredns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:coredns
subjects:
- kind: ServiceAccount
  name: coredns
  namespace: kube-system
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: coredns
  namespace: kube-system
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
    kubernetes.io/name: "CoreDNS"
spec:
  selector:
    matchLabels:
      k8s-app: kube-dns
  template:
    metadata:
      labels:
        k8s-app: kube-dns
      annotations:
        seccomp.security.alpha.kubernetes.io/pod: docker/default
    spec:
      priorityClassName: system-node-critical
      serviceAccountName: coredns
      tolerations:
        - operator: "Exists"
      nodeSelector:
        gravitational.io/k8s-role: master
      containers:
      - name: coredns
        image: coredns/coredns:1.7.0
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            cpu: 200m
            memory: 170Mi
          requests:
            cpu: 100m
            memory: 70Mi
        args: [ "-conf", "/etc/coredns/Corefile" ]
        volumeMounts:
        - name: config-volume
          mountPath: /etc/coredns
          readOnly: true
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 9153
          name: metrics
          protocol: TCP
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - all
          readOnlyRootFilesystem: true
          runAsNonRoot: false
          # TODO(knisbet) need a build of coredns that has setcap for net_bind_service enabled
          runAsUser: 0
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 5
      dnsPolicy: Default
      volumes:
        - name: config-volume
          configMap:
            name: coredns
            items:
            - key: Corefile
              path: Corefile
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coredns-worker
  namespace: kube-system
  labels:
    k8s-app: kube-dns-worker
    kubernetes.io/cluster-service: "true"
    addonmanager.kubernetes.io/mode: Reconcile
    kubernetes.io/name: "CoreDNS"
spec:
  replicas: 0
  selector:
    matchLabels:
      k8s-app: kube-dns-worker
  template:
    metadata:
      labels:
        k8s-app: kube-dns-worker
      annotations:
        seccomp.security.alpha.kubernetes.io/pod: docker/default
    spec:
      priorityClassName: system-node-critical
      serviceAccountName: coredns
      tolerations:
        - operator: "Exists"
      nodeSelector:
        gravitational.io/k8s-role: node
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: k8s-app
                operator: In
                values:
                - coredns
            topologyKey: "kubernetes.io/hostname"
      containers:
      - name: coredns
        image: coredns/coredns:1.7.0
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: 170Mi
          requests:
            cpu: 100m
            memory: 70Mi
        args: [ "-conf", "/etc/coredns/Corefile" ]
        volumeMounts:
        - name: config-volume
          mountPath: /etc/coredns
          readOnly: true
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - all
          readOnlyRootFilesystem: true
          runAsNonRoot: false
          # TODO(knisbet) need a build of coredns that has setcap for net_bind_service enabled
          runAsUser: 0
        ports:
        - containerPort: 53
          name: dns
          protocol: UDP
        - containerPort: 53
          name: dns-tcp
          protocol: TCP
        - containerPort: 9153
          name: metrics
          protocol: TCP
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 60
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 5
      dnsPolicy: Default
      volumes:
        - name: config-volume
          configMap:
            name: coredns
            items:
            - key: Corefile
              path: Corefile
---
apiVersion: v1
kind: Service
metadata:
  name: kube-dns
  namespace: kube-system
  annotations:
    prometheus.io/port: "9153"
    prometheus.io/scrape: "true"
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: "CoreDNS"
spec:
  selector:
    k8s-app: kube-dns
  ports:
  - name: dns
    port: 53
    protocol: UDP
  - name: dns-tcp
    port: 53
    protocol: TCP
  - name: metrics
    port: 9153
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: kube-dns-worker
  namespace: kube-system
  annotations:
    prometheus.io/port: "9153"
    prometheus.io/scrape: "true"
  labels:
    k8s-app: kube-dns-worker
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: "CoreDNS"
spec:
  selector:
    k8s-app: kube-dns-worker
  ports:
  - name: dns
    port: 53
    protocol: UDP
  - name: dns-tcp
    port: 53
    protocol: TCP
  - name: metrics
    port: 9153
    protocol: TCP
#
# Cluster Proportional Autoscaler
# Scale the coredns deployment proportionally to the cluster size
# https://github.com/kubernetes-sigs/cluster-proportional-autoscaler
# https://github.com/kubernetes-sigs/cluster-proportional-autoscaler/tree/master/examples
---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: cluster-proportional-autoscaler-coredns
  namespace: kube-system
---
apiVersion: extensions/v1beta1
kind: PodSecurityPolicy
metadata:
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default
    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default
  name: cluster-proportional-autoscaler
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - All
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-proportional-autoscaler-coredns
rules:
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["list", "watch"]
  - apiGroups:
    - policy
    resources:
    - podsecuritypolicies
    verbs:
    - use
    resourceNames:
    - cluster-proportional-autoscaler
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-proportional-autoscaler-coredns
  namespace: kube-system
rules:
  - apiGroups: [""]
    resources: ["replicationcontrollers/scale"]
    verbs: ["get", "update"]
  - apiGroups: ["extensions","apps"]
    resources: ["deployments/scale", "replicasets/scale"]
    verbs: ["get", "update"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get"]
    resourceNames: ["autoscaler-coredns-worker", "autoscaler-coredns-master"]
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-proportional-autoscaler-coredns
subjects:
  - kind: ServiceAccount
    name: cluster-proportional-autoscaler-coredns
    namespace: kube-system
roleRef:
  kind: ClusterRole
  name: cluster-proportional-autoscaler-coredns
  apiGroup: rbac.authorization.k8s.io
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-proportional-autoscaler-coredns
  namespace: kube-system
subjects:
  - kind: ServiceAccount
    name: cluster-proportional-autoscaler-coredns
    namespace: kube-system
roleRef:
  kind: Role
  name: cluster-proportional-autoscaler-coredns
  apiGroup: rbac.authorization.k8s.io
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: autoscaler-coredns-worker
  namespace: kube-system
data:
  # When cluster is using large nodes(with more cores), "coresPerReplica" should dominate.
  # If using small nodes, "nodesPerReplica" should dominate.
  # Parameters based on kubernetes defaults: https://github.com/kubernetes/kubernetes/blob/f65f868aa041e108a73a014df360427c6e05e493/cluster/addons/dns-horizontal-autoscaler/dns-horizontal-autoscaler.yaml
  linear: '{"coresPerReplica":256,"includeUnschedulableNodes":true,"nodesPerReplica":16,"preventSinglePointFailure":true}'
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: autoscaler-coredns-worker
  namespace: kube-system
  labels:
    k8s-app: autoscaler-coredns-worker
spec:
  replicas: 1
  selector:
    matchLabels:
      k8s-app: autoscaler-coredns-worker
  template:
    metadata:
      labels:
        k8s-app: autoscaler-coredns-worker
    spec:
      serviceAccountName: cluster-proportional-autoscaler-coredns
      tolerations:
        - operator: "Exists"
      containers:
        - image: k8s.gcr.io/cpa/cluster-proportional-autoscaler-amd64:1.8.3
          name: autoscaler
          command:
            - /cluster-proportional-autoscaler
            - --namespace=kube-system
            - --configmap=autoscaler-coredns-worker
            - --target=deployment/coredns-worker
            - --nodelabels=gravitational.io/k8s-role=node
            - --poll-period-seconds=60
            - --logtostderr=true
            - --v=2
          securityContext:
              # nonroot user is 65532 as per https://github.com/GoogleContainerTools/distroless/issues/235
              runAsUser: 65532
              allowPrivilegeEscalation: false
              capabilities:
                drop:
                - all
              readOnlyRootFilesystem: true
              runAsNonRoot: true
