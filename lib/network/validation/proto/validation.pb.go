// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: validation.proto

package proto

import (
	context "context"
	fmt "fmt"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	agentpb "github.com/gravitational/satellite/agent/proto/agentpb"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CheckDisksRequest describes a disks performance test request.
type CheckDisksRequest struct {
	// Spec is a fio job spec describing the test to perform.
	Spec                 []byte   `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDisksRequest) Reset()         { *m = CheckDisksRequest{} }
func (m *CheckDisksRequest) String() string { return proto.CompactTextString(m) }
func (*CheckDisksRequest) ProtoMessage()    {}
func (*CheckDisksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{0}
}
func (m *CheckDisksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDisksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDisksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDisksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDisksRequest.Merge(m, src)
}
func (m *CheckDisksRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckDisksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDisksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDisksRequest proto.InternalMessageInfo

func (m *CheckDisksRequest) GetSpec() []byte {
	if m != nil {
		return m.Spec
	}
	return nil
}

// CheckDisksResponse is the result of the disk performance test.
type CheckDisksResponse struct {
	// Result is the fio job result output in json format.
	Result               []byte   `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDisksResponse) Reset()         { *m = CheckDisksResponse{} }
func (m *CheckDisksResponse) String() string { return proto.CompactTextString(m) }
func (*CheckDisksResponse) ProtoMessage()    {}
func (*CheckDisksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{1}
}
func (m *CheckDisksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDisksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDisksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDisksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDisksResponse.Merge(m, src)
}
func (m *CheckDisksResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckDisksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDisksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDisksResponse proto.InternalMessageInfo

func (m *CheckDisksResponse) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// CheckPortsRequest describes a ports network test request
type CheckPortsRequest struct {
	// Listen specifies the listen endpoints
	Listen []*Addr `protobuf:"bytes,1,rep,name=listen,proto3" json:"listen,omitempty"`
	// Ping specifies the ping endpoints
	Ping []*Addr `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	// Duration specifies the maximum duration for the request
	Duration             *types.Duration `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckPortsRequest) Reset()         { *m = CheckPortsRequest{} }
func (m *CheckPortsRequest) String() string { return proto.CompactTextString(m) }
func (*CheckPortsRequest) ProtoMessage()    {}
func (*CheckPortsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{2}
}
func (m *CheckPortsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPortsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPortsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPortsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPortsRequest.Merge(m, src)
}
func (m *CheckPortsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckPortsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPortsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPortsRequest proto.InternalMessageInfo

func (m *CheckPortsRequest) GetListen() []*Addr {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckPortsRequest) GetPing() []*Addr {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *CheckPortsRequest) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// CheckPortsResponse describes the results of a ports network test
type CheckPortsResponse struct {
	// Listen describes the listen test results
	Listen []*ServerResult `protobuf:"bytes,1,rep,name=listen,proto3" json:"listen,omitempty"`
	// Ping describes the ping test results
	Ping                 []*ServerResult `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckPortsResponse) Reset()         { *m = CheckPortsResponse{} }
func (m *CheckPortsResponse) String() string { return proto.CompactTextString(m) }
func (*CheckPortsResponse) ProtoMessage()    {}
func (*CheckPortsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{3}
}
func (m *CheckPortsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPortsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPortsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPortsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPortsResponse.Merge(m, src)
}
func (m *CheckPortsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckPortsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPortsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPortsResponse proto.InternalMessageInfo

func (m *CheckPortsResponse) GetListen() []*ServerResult {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckPortsResponse) GetPing() []*ServerResult {
	if m != nil {
		return m.Ping
	}
	return nil
}

// CheckBandwidthRequest describes a bandwidth check network test
type CheckBandwidthRequest struct {
	// Listen specifies the listen endpoint
	Listen *Addr `protobuf:"bytes,1,opt,name=listen,proto3" json:"listen,omitempty"`
	// Ping specifies the ping endpoints
	Ping []*Addr `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	// Duration specifies the maximum duration for the request
	Duration             *types.Duration `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckBandwidthRequest) Reset()         { *m = CheckBandwidthRequest{} }
func (m *CheckBandwidthRequest) String() string { return proto.CompactTextString(m) }
func (*CheckBandwidthRequest) ProtoMessage()    {}
func (*CheckBandwidthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{4}
}
func (m *CheckBandwidthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckBandwidthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckBandwidthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckBandwidthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBandwidthRequest.Merge(m, src)
}
func (m *CheckBandwidthRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckBandwidthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBandwidthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBandwidthRequest proto.InternalMessageInfo

func (m *CheckBandwidthRequest) GetListen() *Addr {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckBandwidthRequest) GetPing() []*Addr {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *CheckBandwidthRequest) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// CheckBandwidthResponse describes the results of a bandwidth check
type CheckBandwidthResponse struct {
	// Bandwidth is the result of a bandwidth test
	Bandwidth            uint64   `protobuf:"varint,1,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckBandwidthResponse) Reset()         { *m = CheckBandwidthResponse{} }
func (m *CheckBandwidthResponse) String() string { return proto.CompactTextString(m) }
func (*CheckBandwidthResponse) ProtoMessage()    {}
func (*CheckBandwidthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{5}
}
func (m *CheckBandwidthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckBandwidthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckBandwidthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckBandwidthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBandwidthResponse.Merge(m, src)
}
func (m *CheckBandwidthResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckBandwidthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBandwidthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBandwidthResponse proto.InternalMessageInfo

func (m *CheckBandwidthResponse) GetBandwidth() uint64 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

// ServerResult defines the operation result for a server
type ServerResult struct {
	// Code specifies the result, with 0 for success
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// Error specifies an error message
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Server specifies which server the result is from
	Server               *Addr    `protobuf:"bytes,3,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerResult) Reset()         { *m = ServerResult{} }
func (m *ServerResult) String() string { return proto.CompactTextString(m) }
func (*ServerResult) ProtoMessage()    {}
func (*ServerResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{6}
}
func (m *ServerResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerResult.Merge(m, src)
}
func (m *ServerResult) XXX_Size() int {
	return m.Size()
}
func (m *ServerResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerResult.DiscardUnknown(m)
}

var xxx_messageInfo_ServerResult proto.InternalMessageInfo

func (m *ServerResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ServerResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ServerResult) GetServer() *Addr {
	if m != nil {
		return m.Server
	}
	return nil
}

// Addr defines an endpoint address
type Addr struct {
	// Network specifies the type of network (tcp, udp)
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	// Addr specifies the address as IP or IP:port
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Addr) Reset()         { *m = Addr{} }
func (m *Addr) String() string { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()    {}
func (*Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{7}
}
func (m *Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addr.Merge(m, src)
}
func (m *Addr) XXX_Size() int {
	return m.Size()
}
func (m *Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_Addr.DiscardUnknown(m)
}

var xxx_messageInfo_Addr proto.InternalMessageInfo

func (m *Addr) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *Addr) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// ValidateRequest defines a request to run validation
type ValidateRequest struct {
	// Manifest specifies the application manifest with
	// requirements
	Manifest []byte `protobuf:"bytes,1,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Profile specifies the node profile to validate against
	Profile string `protobuf:"bytes,2,opt,name=profile,proto3" json:"profile,omitempty"`
	// FullRequirements forces validation of all requirements
	// from the manifest.
	// This is used to validate requirements during installation.
	FullRequirements bool `protobuf:"varint,3,opt,name=full_requirements,json=fullRequirements,proto3" json:"full_requirements,omitempty"`
	// ValidateOptions is additional validation options
	Options *ValidateOptions `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	// Docker specifies the Docker configuration to validate
	Docker               *Docker  `protobuf:"bytes,5,opt,name=docker,proto3" json:"docker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateRequest) Reset()         { *m = ValidateRequest{} }
func (m *ValidateRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateRequest) ProtoMessage()    {}
func (*ValidateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{8}
}
func (m *ValidateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateRequest.Merge(m, src)
}
func (m *ValidateRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateRequest proto.InternalMessageInfo

func (m *ValidateRequest) GetManifest() []byte {
	if m != nil {
		return m.Manifest
	}
	return nil
}

func (m *ValidateRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

func (m *ValidateRequest) GetFullRequirements() bool {
	if m != nil {
		return m.FullRequirements
	}
	return false
}

func (m *ValidateRequest) GetOptions() *ValidateOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ValidateRequest) GetDocker() *Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

// ValidateResponse describes a validation response
type ValidateResponse struct {
	// Failed lists the failed probes
	Failed               []*agentpb.Probe `protobuf:"bytes,1,rep,name=failed,proto3" json:"failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ValidateResponse) Reset()         { *m = ValidateResponse{} }
func (m *ValidateResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateResponse) ProtoMessage()    {}
func (*ValidateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{9}
}
func (m *ValidateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateResponse.Merge(m, src)
}
func (m *ValidateResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateResponse proto.InternalMessageInfo

func (m *ValidateResponse) GetFailed() []*agentpb.Probe {
	if m != nil {
		return m.Failed
	}
	return nil
}

// ValidateOptions is additional validation options
type ValidateOptions struct {
	// VxlanPort is the custom overlay network port
	VxlanPort int32 `protobuf:"varint,1,opt,name=vxlan_port,json=vxlanPort,proto3" json:"vxlan_port,omitempty"`
	// DnsAddrs specifies the list of listen IP addresses for coredns
	DnsAddrs []string `protobuf:"bytes,2,rep,name=dns_addrs,json=dnsAddrs,proto3" json:"dns_addrs,omitempty"`
	// DnsPort specifies the DNS port for coredns
	DnsPort              int32    `protobuf:"varint,3,opt,name=dns_port,json=dnsPort,proto3" json:"dns_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateOptions) Reset()         { *m = ValidateOptions{} }
func (m *ValidateOptions) String() string { return proto.CompactTextString(m) }
func (*ValidateOptions) ProtoMessage()    {}
func (*ValidateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{10}
}
func (m *ValidateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateOptions.Merge(m, src)
}
func (m *ValidateOptions) XXX_Size() int {
	return m.Size()
}
func (m *ValidateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateOptions proto.InternalMessageInfo

func (m *ValidateOptions) GetVxlanPort() int32 {
	if m != nil {
		return m.VxlanPort
	}
	return 0
}

func (m *ValidateOptions) GetDnsAddrs() []string {
	if m != nil {
		return m.DnsAddrs
	}
	return nil
}

func (m *ValidateOptions) GetDnsPort() int32 {
	if m != nil {
		return m.DnsPort
	}
	return 0
}

// Docker groups Docker-relevant attributes to validate
type Docker struct {
	// StorageDriver specifies the Docker storage driver
	StorageDriver        string   `protobuf:"bytes,1,opt,name=storage_driver,json=storageDriver,proto3" json:"storage_driver,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Docker) Reset()         { *m = Docker{} }
func (m *Docker) String() string { return proto.CompactTextString(m) }
func (*Docker) ProtoMessage()    {}
func (*Docker) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{11}
}
func (m *Docker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Docker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Docker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Docker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Docker.Merge(m, src)
}
func (m *Docker) XXX_Size() int {
	return m.Size()
}
func (m *Docker) XXX_DiscardUnknown() {
	xxx_messageInfo_Docker.DiscardUnknown(m)
}

var xxx_messageInfo_Docker proto.InternalMessageInfo

func (m *Docker) GetStorageDriver() string {
	if m != nil {
		return m.StorageDriver
	}
	return ""
}

func init() {
	proto.RegisterType((*CheckDisksRequest)(nil), "proto.CheckDisksRequest")
	proto.RegisterType((*CheckDisksResponse)(nil), "proto.CheckDisksResponse")
	proto.RegisterType((*CheckPortsRequest)(nil), "proto.CheckPortsRequest")
	proto.RegisterType((*CheckPortsResponse)(nil), "proto.CheckPortsResponse")
	proto.RegisterType((*CheckBandwidthRequest)(nil), "proto.CheckBandwidthRequest")
	proto.RegisterType((*CheckBandwidthResponse)(nil), "proto.CheckBandwidthResponse")
	proto.RegisterType((*ServerResult)(nil), "proto.ServerResult")
	proto.RegisterType((*Addr)(nil), "proto.Addr")
	proto.RegisterType((*ValidateRequest)(nil), "proto.ValidateRequest")
	proto.RegisterType((*ValidateResponse)(nil), "proto.ValidateResponse")
	proto.RegisterType((*ValidateOptions)(nil), "proto.ValidateOptions")
	proto.RegisterType((*Docker)(nil), "proto.Docker")
}

func init() { proto.RegisterFile("validation.proto", fileDescriptor_bfc2ab0b60b7792f) }

var fileDescriptor_bfc2ab0b60b7792f = []byte{
	// 669 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xcd, 0x6e, 0x13, 0x31,
	0x10, 0x66, 0xdb, 0x24, 0x4d, 0xa6, 0x3f, 0xa4, 0x2e, 0x94, 0x6d, 0x68, 0x43, 0xb4, 0xa8, 0x34,
	0x52, 0xd1, 0x06, 0x95, 0x9f, 0x03, 0x9c, 0x5a, 0x72, 0x45, 0x54, 0x46, 0xea, 0x0d, 0x45, 0x9b,
	0xd8, 0x49, 0x97, 0x6c, 0xed, 0xad, 0xbd, 0x69, 0x79, 0x0c, 0x0e, 0x1c, 0x38, 0xf1, 0x3c, 0x5c,
	0x90, 0x78, 0x04, 0x54, 0x5e, 0x04, 0xd9, 0x3b, 0xce, 0x5f, 0xc3, 0x95, 0x93, 0x3d, 0x33, 0xdf,
	0x8c, 0xbf, 0x6f, 0x3c, 0x36, 0x54, 0xaf, 0xa2, 0x24, 0x66, 0x51, 0x16, 0x4b, 0x11, 0xa6, 0x4a,
	0x66, 0x92, 0x14, 0xed, 0x52, 0xab, 0x0f, 0xa4, 0x1c, 0x24, 0xbc, 0x65, 0xad, 0xee, 0xa8, 0xdf,
	0x62, 0x23, 0x35, 0x05, 0xab, 0x6d, 0x45, 0x03, 0x2e, 0xb2, 0xb4, 0xdb, 0xb2, 0x6b, 0xee, 0x0c,
	0x0e, 0x60, 0xf3, 0xed, 0x39, 0xef, 0x0d, 0xdb, 0xb1, 0x1e, 0x6a, 0xca, 0x2f, 0x47, 0x5c, 0x67,
	0x84, 0x40, 0x41, 0xa7, 0xbc, 0xe7, 0x7b, 0x0d, 0xaf, 0xb9, 0x46, 0xed, 0x3e, 0x78, 0x0a, 0x64,
	0x1a, 0xa8, 0x53, 0x29, 0x34, 0x27, 0xdb, 0x50, 0x52, 0x5c, 0x8f, 0x92, 0x0c, 0xb1, 0x68, 0x05,
	0x5f, 0x3c, 0xac, 0x7b, 0x2a, 0x55, 0x36, 0xae, 0xfb, 0x18, 0x4a, 0x49, 0xac, 0x33, 0x2e, 0x7c,
	0xaf, 0xb1, 0xdc, 0x5c, 0x3d, 0x5a, 0xcd, 0x49, 0x84, 0xc7, 0x8c, 0x29, 0x8a, 0x21, 0xf2, 0x08,
	0x0a, 0x69, 0x2c, 0x06, 0xfe, 0xd2, 0x6d, 0x88, 0x0d, 0x90, 0x97, 0x50, 0x76, 0xca, 0xfc, 0xe5,
	0x86, 0xd7, 0x5c, 0x3d, 0xda, 0x09, 0x73, 0xe9, 0xa1, 0x93, 0x1e, 0xb6, 0x11, 0x40, 0xc7, 0xd0,
	0xe0, 0x13, 0x0a, 0x40, 0x46, 0x28, 0xe0, 0x70, 0x8e, 0xd2, 0x16, 0x9e, 0xf7, 0x81, 0xab, 0x2b,
	0xae, 0xa8, 0x55, 0x33, 0xa6, 0x76, 0x30, 0x43, 0x6d, 0x21, 0xd4, 0x02, 0x82, 0xaf, 0x1e, 0xdc,
	0xb7, 0x87, 0x9d, 0x44, 0x82, 0x5d, 0xc7, 0x2c, 0x3b, 0x5f, 0xd4, 0x02, 0xef, 0x7f, 0xb7, 0xe0,
	0x15, 0x6c, 0xcf, 0xb3, 0xc2, 0x36, 0xec, 0x42, 0xa5, 0xeb, 0x9c, 0x96, 0x59, 0x81, 0x4e, 0x1c,
	0xc1, 0x47, 0x58, 0x9b, 0x16, 0x69, 0xe6, 0xa3, 0x27, 0x19, 0xb7, 0xc0, 0x22, 0xb5, 0x7b, 0x72,
	0x0f, 0x8a, 0x5c, 0x29, 0xa9, 0xfc, 0xa5, 0x86, 0xd7, 0xac, 0xd0, 0xdc, 0x30, 0x72, 0xb5, 0xcd,
	0x44, 0x9a, 0xb3, 0x72, 0xf3, 0x50, 0xf0, 0x02, 0x0a, 0xc6, 0x26, 0x3e, 0xac, 0x08, 0x9e, 0x5d,
	0x4b, 0x35, 0xb4, 0x95, 0x2b, 0xd4, 0x99, 0xe6, 0xc0, 0x88, 0x31, 0x57, 0xdb, 0xee, 0x83, 0x9f,
	0x1e, 0xdc, 0x3d, 0xcb, 0x9f, 0x02, 0x77, 0xdd, 0xad, 0x41, 0xf9, 0x22, 0x12, 0x71, 0x9f, 0x6b,
	0x37, 0x90, 0x63, 0xdb, 0x54, 0x4f, 0x95, 0xec, 0xc7, 0x09, 0xc7, 0x32, 0xce, 0x24, 0x87, 0xb0,
	0xd9, 0x1f, 0x25, 0x49, 0x47, 0xf1, 0xcb, 0x51, 0xac, 0xf8, 0x05, 0x17, 0x99, 0xb6, 0x7c, 0xcb,
	0xb4, 0x6a, 0x02, 0x74, 0xca, 0x4f, 0x9e, 0xc1, 0x8a, 0x4c, 0x4d, 0x37, 0xb5, 0x5f, 0xb0, 0x92,
	0xb6, 0x51, 0x92, 0xe3, 0xf2, 0x3e, 0x8f, 0x52, 0x07, 0x23, 0xfb, 0x50, 0x62, 0xb2, 0x37, 0xe4,
	0xca, 0x2f, 0xda, 0x84, 0x75, 0x4c, 0x68, 0x5b, 0x27, 0xc5, 0x60, 0xf0, 0x1a, 0xaa, 0x13, 0x39,
	0x78, 0x2d, 0x4f, 0xa0, 0xd4, 0x8f, 0xe2, 0x84, 0x33, 0x9c, 0xce, 0x8d, 0x10, 0xdf, 0x70, 0x78,
	0xaa, 0x64, 0x97, 0x53, 0x8c, 0x06, 0xe7, 0x93, 0x56, 0xe0, 0xf1, 0x64, 0x0f, 0xe0, 0xea, 0x73,
	0x12, 0x89, 0x4e, 0x2a, 0x55, 0x86, 0x37, 0x55, 0xb1, 0x1e, 0xf3, 0x00, 0xc8, 0x43, 0xa8, 0x30,
	0xa1, 0x3b, 0xa6, 0x93, 0xda, 0xce, 0x59, 0x85, 0x96, 0x99, 0xd0, 0xe6, 0x1e, 0x34, 0xd9, 0x01,
	0xb3, 0xcf, 0x33, 0x97, 0x6d, 0xe6, 0x0a, 0x13, 0xda, 0xe4, 0x05, 0x2d, 0x28, 0xe5, 0xbc, 0xc9,
	0x3e, 0x6c, 0xe8, 0x4c, 0xaa, 0x68, 0xc0, 0x3b, 0x4c, 0xc5, 0xe6, 0x8a, 0xf3, 0x4b, 0x5b, 0x47,
	0x6f, 0xdb, 0x3a, 0x8f, 0xbe, 0x2f, 0x01, 0x9c, 0x8d, 0x7f, 0x2c, 0x72, 0x0c, 0x30, 0x79, 0x85,
	0xc4, 0xc7, 0x56, 0xdc, 0xfa, 0x2a, 0x6a, 0x3b, 0x0b, 0x22, 0xd8, 0x94, 0x77, 0xb0, 0x31, 0x3b,
	0xc5, 0x64, 0x77, 0x1a, 0x3c, 0xff, 0xe4, 0x6a, 0x7b, 0xff, 0x88, 0x62, 0x39, 0xc7, 0xc8, 0x7e,
	0x6c, 0xb3, 0x8c, 0xa6, 0x3f, 0xc5, 0x59, 0x46, 0xb3, 0xbf, 0xe0, 0x1b, 0x28, 0xbb, 0xf6, 0x93,
	0xf9, 0x71, 0x70, 0xe9, 0x0f, 0x6e, 0xf9, 0xf3, 0xe4, 0x93, 0xea, 0x8f, 0x9b, 0xba, 0xf7, 0xeb,
	0xa6, 0xee, 0xfd, 0xbe, 0xa9, 0x7b, 0xdf, 0xfe, 0xd4, 0xef, 0x74, 0x4b, 0x16, 0xf9, 0xfc, 0x6f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xb5, 0x22, 0x90, 0xea, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ValidationClient is the client API for Validation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ValidationClient interface {
	// CheckPorts executes a ports network test
	CheckPorts(ctx context.Context, in *CheckPortsRequest, opts ...grpc.CallOption) (*CheckPortsResponse, error)
	// CheckBandwidth executes a bandwidth network test
	CheckBandwidth(ctx context.Context, in *CheckBandwidthRequest, opts ...grpc.CallOption) (*CheckBandwidthResponse, error)
	// CheckDisks executes performance test for the specified disks
	CheckDisks(ctx context.Context, in *CheckDisksRequest, opts ...grpc.CallOption) (*CheckDisksResponse, error)
	// Validate validatest this node against the requirements
	// from a manifest.
	Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
}

type validationClient struct {
	cc *grpc.ClientConn
}

func NewValidationClient(cc *grpc.ClientConn) ValidationClient {
	return &validationClient{cc}
}

func (c *validationClient) CheckPorts(ctx context.Context, in *CheckPortsRequest, opts ...grpc.CallOption) (*CheckPortsResponse, error) {
	out := new(CheckPortsResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) CheckBandwidth(ctx context.Context, in *CheckBandwidthRequest, opts ...grpc.CallOption) (*CheckBandwidthResponse, error) {
	out := new(CheckBandwidthResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckBandwidth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) CheckDisks(ctx context.Context, in *CheckDisksRequest, opts ...grpc.CallOption) (*CheckDisksResponse, error) {
	out := new(CheckDisksResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckDisks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidationServer is the server API for Validation service.
type ValidationServer interface {
	// CheckPorts executes a ports network test
	CheckPorts(context.Context, *CheckPortsRequest) (*CheckPortsResponse, error)
	// CheckBandwidth executes a bandwidth network test
	CheckBandwidth(context.Context, *CheckBandwidthRequest) (*CheckBandwidthResponse, error)
	// CheckDisks executes performance test for the specified disks
	CheckDisks(context.Context, *CheckDisksRequest) (*CheckDisksResponse, error)
	// Validate validatest this node against the requirements
	// from a manifest.
	Validate(context.Context, *ValidateRequest) (*ValidateResponse, error)
}

func RegisterValidationServer(s *grpc.Server, srv ValidationServer) {
	s.RegisterService(&_Validation_serviceDesc, srv)
}

func _Validation_CheckPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckPorts(ctx, req.(*CheckPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_CheckBandwidth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBandwidthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckBandwidth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckBandwidth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckBandwidth(ctx, req.(*CheckBandwidthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_CheckDisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckDisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckDisks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckDisks(ctx, req.(*CheckDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).Validate(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Validation_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Validation",
	HandlerType: (*ValidationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckPorts",
			Handler:    _Validation_CheckPorts_Handler,
		},
		{
			MethodName: "CheckBandwidth",
			Handler:    _Validation_CheckBandwidth_Handler,
		},
		{
			MethodName: "CheckDisks",
			Handler:    _Validation_CheckDisks_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _Validation_Validate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "validation.proto",
}

func (m *CheckDisksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDisksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Spec) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Spec)))
		i += copy(dAtA[i:], m.Spec)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckDisksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDisksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckPortsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPortsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, msg := range m.Listen {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Duration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Duration.Size()))
		n1, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckPortsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPortsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, msg := range m.Listen {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckBandwidthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBandwidthRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Listen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Listen.Size()))
		n2, err := m.Listen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Duration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Duration.Size()))
		n3, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckBandwidthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBandwidthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bandwidth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Bandwidth))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Code))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Server != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Server.Size()))
		n4, err := m.Server.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Manifest) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Manifest)))
		i += copy(dAtA[i:], m.Manifest)
	}
	if len(m.Profile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Profile)))
		i += copy(dAtA[i:], m.Profile)
	}
	if m.FullRequirements {
		dAtA[i] = 0x18
		i++
		if m.FullRequirements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Options.Size()))
		n5, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Docker != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Docker.Size()))
		n6, err := m.Docker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Failed) > 0 {
		for _, msg := range m.Failed {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VxlanPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.VxlanPort))
	}
	if len(m.DnsAddrs) > 0 {
		for _, s := range m.DnsAddrs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DnsPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.DnsPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Docker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Docker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDriver) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.StorageDriver)))
		i += copy(dAtA[i:], m.StorageDriver)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintValidation(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CheckDisksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDisksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckPortsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, e := range m.Listen {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckPortsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, e := range m.Listen {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckBandwidthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Listen != nil {
		l = m.Listen.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckBandwidthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth != 0 {
		n += 1 + sovValidation(uint64(m.Bandwidth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovValidation(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.FullRequirements {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Docker != nil {
		l = m.Docker.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Failed) > 0 {
		for _, e := range m.Failed {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VxlanPort != 0 {
		n += 1 + sovValidation(uint64(m.VxlanPort))
	}
	if len(m.DnsAddrs) > 0 {
		for _, s := range m.DnsAddrs {
			l = len(s)
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.DnsPort != 0 {
		n += 1 + sovValidation(uint64(m.DnsPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Docker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDriver)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovValidation(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozValidation(x uint64) (n int) {
	return sovValidation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CheckDisksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDisksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDisksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = append(m.Spec[:0], dAtA[iNdEx:postIndex]...)
			if m.Spec == nil {
				m.Spec = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDisksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDisksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDisksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPortsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPortsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPortsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listen = append(m.Listen, &Addr{})
			if err := m.Listen[len(m.Listen)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &Addr{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPortsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPortsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPortsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listen = append(m.Listen, &ServerResult{})
			if err := m.Listen[len(m.Listen)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &ServerResult{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBandwidthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBandwidthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBandwidthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Listen == nil {
				m.Listen = &Addr{}
			}
			if err := m.Listen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &Addr{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBandwidthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBandwidthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBandwidthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &Addr{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = append(m.Manifest[:0], dAtA[iNdEx:postIndex]...)
			if m.Manifest == nil {
				m.Manifest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullRequirements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullRequirements = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ValidateOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Docker == nil {
				m.Docker = &Docker{}
			}
			if err := m.Docker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failed = append(m.Failed, &agentpb.Probe{})
			if err := m.Failed[len(m.Failed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanPort", wireType)
			}
			m.VxlanPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VxlanPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsAddrs = append(m.DnsAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsPort", wireType)
			}
			m.DnsPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Docker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Docker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Docker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipValidation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthValidation
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthValidation
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowValidation
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipValidation(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthValidation
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthValidation = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowValidation   = fmt.Errorf("proto: integer overflow")
)
