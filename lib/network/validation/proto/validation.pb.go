// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: validation.proto

package proto

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	agentpb "github.com/gravitational/satellite/agent/proto/agentpb"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CheckPortsRequest describes a ports network test request
type CheckPortsRequest struct {
	// Listen specifies the listen endpoints
	Listen []*Addr `protobuf:"bytes,1,rep,name=listen,proto3" json:"listen,omitempty"`
	// Ping specifies the ping endpoints
	Ping []*Addr `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	// Duration specifies the maximum duration for the request
	Duration             *types.Duration `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckPortsRequest) Reset()         { *m = CheckPortsRequest{} }
func (m *CheckPortsRequest) String() string { return proto.CompactTextString(m) }
func (*CheckPortsRequest) ProtoMessage()    {}
func (*CheckPortsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{0}
}
func (m *CheckPortsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPortsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPortsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPortsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPortsRequest.Merge(m, src)
}
func (m *CheckPortsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckPortsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPortsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPortsRequest proto.InternalMessageInfo

func (m *CheckPortsRequest) GetListen() []*Addr {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckPortsRequest) GetPing() []*Addr {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *CheckPortsRequest) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// CheckPortsResponse describes the results of a ports network test
type CheckPortsResponse struct {
	// Listen describes the listen test results
	Listen []*ServerResult `protobuf:"bytes,1,rep,name=listen,proto3" json:"listen,omitempty"`
	// Ping describes the ping test results
	Ping                 []*ServerResult `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckPortsResponse) Reset()         { *m = CheckPortsResponse{} }
func (m *CheckPortsResponse) String() string { return proto.CompactTextString(m) }
func (*CheckPortsResponse) ProtoMessage()    {}
func (*CheckPortsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{1}
}
func (m *CheckPortsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPortsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPortsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPortsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPortsResponse.Merge(m, src)
}
func (m *CheckPortsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckPortsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPortsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPortsResponse proto.InternalMessageInfo

func (m *CheckPortsResponse) GetListen() []*ServerResult {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckPortsResponse) GetPing() []*ServerResult {
	if m != nil {
		return m.Ping
	}
	return nil
}

// CheckBandwidthRequest describes a bandwidth check network test
type CheckBandwidthRequest struct {
	// Listen specifies the listen endpoint
	Listen *Addr `protobuf:"bytes,1,opt,name=listen,proto3" json:"listen,omitempty"`
	// Ping specifies the ping endpoints
	Ping []*Addr `protobuf:"bytes,2,rep,name=ping,proto3" json:"ping,omitempty"`
	// Duration specifies the maximum duration for the request
	Duration             *types.Duration `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckBandwidthRequest) Reset()         { *m = CheckBandwidthRequest{} }
func (m *CheckBandwidthRequest) String() string { return proto.CompactTextString(m) }
func (*CheckBandwidthRequest) ProtoMessage()    {}
func (*CheckBandwidthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{2}
}
func (m *CheckBandwidthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckBandwidthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckBandwidthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckBandwidthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBandwidthRequest.Merge(m, src)
}
func (m *CheckBandwidthRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckBandwidthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBandwidthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBandwidthRequest proto.InternalMessageInfo

func (m *CheckBandwidthRequest) GetListen() *Addr {
	if m != nil {
		return m.Listen
	}
	return nil
}

func (m *CheckBandwidthRequest) GetPing() []*Addr {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *CheckBandwidthRequest) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// CheckBandwidthResponse describes the results of a bandwidth check
type CheckBandwidthResponse struct {
	// Bandwidth is the result of a bandwidth test
	Bandwidth            uint64   `protobuf:"varint,1,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckBandwidthResponse) Reset()         { *m = CheckBandwidthResponse{} }
func (m *CheckBandwidthResponse) String() string { return proto.CompactTextString(m) }
func (*CheckBandwidthResponse) ProtoMessage()    {}
func (*CheckBandwidthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{3}
}
func (m *CheckBandwidthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckBandwidthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckBandwidthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckBandwidthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBandwidthResponse.Merge(m, src)
}
func (m *CheckBandwidthResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckBandwidthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBandwidthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBandwidthResponse proto.InternalMessageInfo

func (m *CheckBandwidthResponse) GetBandwidth() uint64 {
	if m != nil {
		return m.Bandwidth
	}
	return 0
}

// ServerResult defines the operation result for a server
type ServerResult struct {
	// Code specifies the result, with 0 for success
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// Error specifies an error message
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Server specifies which server the result is from
	Server               *Addr    `protobuf:"bytes,3,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerResult) Reset()         { *m = ServerResult{} }
func (m *ServerResult) String() string { return proto.CompactTextString(m) }
func (*ServerResult) ProtoMessage()    {}
func (*ServerResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{4}
}
func (m *ServerResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerResult.Merge(m, src)
}
func (m *ServerResult) XXX_Size() int {
	return m.Size()
}
func (m *ServerResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerResult.DiscardUnknown(m)
}

var xxx_messageInfo_ServerResult proto.InternalMessageInfo

func (m *ServerResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ServerResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ServerResult) GetServer() *Addr {
	if m != nil {
		return m.Server
	}
	return nil
}

// Addr defines an endpoint address
type Addr struct {
	// Network specifies the type of network (tcp, udp)
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	// Addr specifies the address as IP or IP:port
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Addr) Reset()         { *m = Addr{} }
func (m *Addr) String() string { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()    {}
func (*Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{5}
}
func (m *Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addr.Merge(m, src)
}
func (m *Addr) XXX_Size() int {
	return m.Size()
}
func (m *Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_Addr.DiscardUnknown(m)
}

var xxx_messageInfo_Addr proto.InternalMessageInfo

func (m *Addr) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *Addr) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// ValidateRequest defines a request to run validation
type ValidateRequest struct {
	// Manifest specifies the application manifest with
	// requirements
	Manifest []byte `protobuf:"bytes,1,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Profile specifies the node profile to validate against
	Profile string `protobuf:"bytes,2,opt,name=profile,proto3" json:"profile,omitempty"`
	// FullRequirements forces validation of all requirements
	// from the manifest.
	// This is used to validate requirements during installation.
	FullRequirements bool `protobuf:"varint,3,opt,name=full_requirements,json=fullRequirements,proto3" json:"full_requirements,omitempty"`
	// ValidateOptions is additional validation options
	Options *ValidateOptions `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	// Docker specifies the Docker configuration to validate
	Docker               *Docker  `protobuf:"bytes,5,opt,name=docker,proto3" json:"docker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateRequest) Reset()         { *m = ValidateRequest{} }
func (m *ValidateRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateRequest) ProtoMessage()    {}
func (*ValidateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{6}
}
func (m *ValidateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateRequest.Merge(m, src)
}
func (m *ValidateRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateRequest proto.InternalMessageInfo

func (m *ValidateRequest) GetManifest() []byte {
	if m != nil {
		return m.Manifest
	}
	return nil
}

func (m *ValidateRequest) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

func (m *ValidateRequest) GetFullRequirements() bool {
	if m != nil {
		return m.FullRequirements
	}
	return false
}

func (m *ValidateRequest) GetOptions() *ValidateOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ValidateRequest) GetDocker() *Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

// ValidateResponse describes a validation response
type ValidateResponse struct {
	// Failed lists the failed probes
	Failed               []*agentpb.Probe `protobuf:"bytes,1,rep,name=failed,proto3" json:"failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ValidateResponse) Reset()         { *m = ValidateResponse{} }
func (m *ValidateResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateResponse) ProtoMessage()    {}
func (*ValidateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{7}
}
func (m *ValidateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateResponse.Merge(m, src)
}
func (m *ValidateResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateResponse proto.InternalMessageInfo

func (m *ValidateResponse) GetFailed() []*agentpb.Probe {
	if m != nil {
		return m.Failed
	}
	return nil
}

// ValidateOptions is additional validation options
type ValidateOptions struct {
	// VxlanPort is the custom overlay network port
	VxlanPort int32 `protobuf:"varint,1,opt,name=vxlan_port,json=vxlanPort,proto3" json:"vxlan_port,omitempty"`
	// DnsAddrs specifies the list of listen IP addresses for coredns
	DnsAddrs []string `protobuf:"bytes,2,rep,name=dns_addrs,json=dnsAddrs,proto3" json:"dns_addrs,omitempty"`
	// DnsPort specifies the DNS port for coredns
	DnsPort              int32    `protobuf:"varint,3,opt,name=dns_port,json=dnsPort,proto3" json:"dns_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateOptions) Reset()         { *m = ValidateOptions{} }
func (m *ValidateOptions) String() string { return proto.CompactTextString(m) }
func (*ValidateOptions) ProtoMessage()    {}
func (*ValidateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{8}
}
func (m *ValidateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateOptions.Merge(m, src)
}
func (m *ValidateOptions) XXX_Size() int {
	return m.Size()
}
func (m *ValidateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateOptions proto.InternalMessageInfo

func (m *ValidateOptions) GetVxlanPort() int32 {
	if m != nil {
		return m.VxlanPort
	}
	return 0
}

func (m *ValidateOptions) GetDnsAddrs() []string {
	if m != nil {
		return m.DnsAddrs
	}
	return nil
}

func (m *ValidateOptions) GetDnsPort() int32 {
	if m != nil {
		return m.DnsPort
	}
	return 0
}

// Docker groups Docker-relevant attributes to validate
type Docker struct {
	// StorageDriver specifies the Docker storage driver
	StorageDriver        string   `protobuf:"bytes,1,opt,name=storage_driver,json=storageDriver,proto3" json:"storage_driver,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Docker) Reset()         { *m = Docker{} }
func (m *Docker) String() string { return proto.CompactTextString(m) }
func (*Docker) ProtoMessage()    {}
func (*Docker) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{9}
}
func (m *Docker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Docker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Docker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Docker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Docker.Merge(m, src)
}
func (m *Docker) XXX_Size() int {
	return m.Size()
}
func (m *Docker) XXX_DiscardUnknown() {
	xxx_messageInfo_Docker.DiscardUnknown(m)
}

var xxx_messageInfo_Docker proto.InternalMessageInfo

func (m *Docker) GetStorageDriver() string {
	if m != nil {
		return m.StorageDriver
	}
	return ""
}

// CheckDisksRequest describes a disks performance test request.
type CheckDisksRequest struct {
	// Jobs specifies a list of fio jobs to execute.
	Jobs []*FioJobSpec `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	// FioPath specifies the path to fio executable.
	FioPath              string   `protobuf:"bytes,2,opt,name=fio_path,json=fioPath,proto3" json:"fio_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDisksRequest) Reset()         { *m = CheckDisksRequest{} }
func (m *CheckDisksRequest) String() string { return proto.CompactTextString(m) }
func (*CheckDisksRequest) ProtoMessage()    {}
func (*CheckDisksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{10}
}
func (m *CheckDisksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDisksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDisksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDisksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDisksRequest.Merge(m, src)
}
func (m *CheckDisksRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckDisksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDisksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDisksRequest proto.InternalMessageInfo

func (m *CheckDisksRequest) GetJobs() []*FioJobSpec {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *CheckDisksRequest) GetFioPath() string {
	if m != nil {
		return m.FioPath
	}
	return ""
}

// FioJobSpec describes a single fio job.
type FioJobSpec struct {
	// Name is the job name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ReadWrite specifies the I/O pattern.
	ReadWrite string `protobuf:"bytes,2,opt,name=read_write,json=readWrite,proto3" json:"read_write,omitempty"`
	// IOEngine specifies I/O engine to use.
	IoEngine string `protobuf:"bytes,3,opt,name=io_engine,json=ioEngine,proto3" json:"io_engine,omitempty"`
	// Fdatasync specifies whether to sync data.
	Fdatasync bool `protobuf:"varint,4,opt,name=fdatasync,proto3" json:"fdatasync,omitempty"`
	// Filename specifies the test file path.
	Filename string `protobuf:"bytes,5,opt,name=filename,proto3" json:"filename,omitempty"`
	// BlockSize is the block size used for I/O.
	BlockSize string `protobuf:"bytes,6,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// Size is the total test file size.
	Size_ string `protobuf:"bytes,7,opt,name=size,proto3" json:"size,omitempty"`
	// Runtime limits the maximum test runtime.
	Runtime              *types.Duration `protobuf:"bytes,8,opt,name=runtime,proto3" json:"runtime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FioJobSpec) Reset()         { *m = FioJobSpec{} }
func (m *FioJobSpec) String() string { return proto.CompactTextString(m) }
func (*FioJobSpec) ProtoMessage()    {}
func (*FioJobSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{11}
}
func (m *FioJobSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioJobSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioJobSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioJobSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioJobSpec.Merge(m, src)
}
func (m *FioJobSpec) XXX_Size() int {
	return m.Size()
}
func (m *FioJobSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FioJobSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FioJobSpec proto.InternalMessageInfo

func (m *FioJobSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FioJobSpec) GetReadWrite() string {
	if m != nil {
		return m.ReadWrite
	}
	return ""
}

func (m *FioJobSpec) GetIoEngine() string {
	if m != nil {
		return m.IoEngine
	}
	return ""
}

func (m *FioJobSpec) GetFdatasync() bool {
	if m != nil {
		return m.Fdatasync
	}
	return false
}

func (m *FioJobSpec) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FioJobSpec) GetBlockSize() string {
	if m != nil {
		return m.BlockSize
	}
	return ""
}

func (m *FioJobSpec) GetSize_() string {
	if m != nil {
		return m.Size_
	}
	return ""
}

func (m *FioJobSpec) GetRuntime() *types.Duration {
	if m != nil {
		return m.Runtime
	}
	return nil
}

// CheckDisksResponse is the result of the disk performance test.
type CheckDisksResponse struct {
	// Jobs is a list of executed fio jobs.
	Jobs                 []*FioJobResult `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CheckDisksResponse) Reset()         { *m = CheckDisksResponse{} }
func (m *CheckDisksResponse) String() string { return proto.CompactTextString(m) }
func (*CheckDisksResponse) ProtoMessage()    {}
func (*CheckDisksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{12}
}
func (m *CheckDisksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDisksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDisksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDisksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDisksResponse.Merge(m, src)
}
func (m *CheckDisksResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckDisksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDisksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDisksResponse proto.InternalMessageInfo

func (m *CheckDisksResponse) GetJobs() []*FioJobResult {
	if m != nil {
		return m.Jobs
	}
	return nil
}

// FioJobResult represents a result of a single fio job.
type FioJobResult struct {
	// JobName is the name of the job.
	JobName string `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"jobname"`
	// Read contains metrics related to performed reads.
	Read *FioReadResult `protobuf:"bytes,2,opt,name=read,proto3" json:"read"`
	// Write contains metrics related to performed writes.
	Write *FioWriteResult `protobuf:"bytes,3,opt,name=write,proto3" json:"write"`
	// Sync contains metrics related to performed fsync calls.
	Sync                 *FioSyncResult `protobuf:"bytes,4,opt,name=sync,proto3" json:"sync"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FioJobResult) Reset()         { *m = FioJobResult{} }
func (m *FioJobResult) String() string { return proto.CompactTextString(m) }
func (*FioJobResult) ProtoMessage()    {}
func (*FioJobResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{13}
}
func (m *FioJobResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioJobResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioJobResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioJobResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioJobResult.Merge(m, src)
}
func (m *FioJobResult) XXX_Size() int {
	return m.Size()
}
func (m *FioJobResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FioJobResult.DiscardUnknown(m)
}

var xxx_messageInfo_FioJobResult proto.InternalMessageInfo

func (m *FioJobResult) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

func (m *FioJobResult) GetRead() *FioReadResult {
	if m != nil {
		return m.Read
	}
	return nil
}

func (m *FioJobResult) GetWrite() *FioWriteResult {
	if m != nil {
		return m.Write
	}
	return nil
}

func (m *FioJobResult) GetSync() *FioSyncResult {
	if m != nil {
		return m.Sync
	}
	return nil
}

// FioReadResult contains read-related metrics.
type FioReadResult struct {
	// IOPS is the number of read iops.
	Iops                 float64  `protobuf:"fixed64,1,opt,name=iops,proto3" json:"iops"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FioReadResult) Reset()         { *m = FioReadResult{} }
func (m *FioReadResult) String() string { return proto.CompactTextString(m) }
func (*FioReadResult) ProtoMessage()    {}
func (*FioReadResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{14}
}
func (m *FioReadResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioReadResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioReadResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioReadResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioReadResult.Merge(m, src)
}
func (m *FioReadResult) XXX_Size() int {
	return m.Size()
}
func (m *FioReadResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FioReadResult.DiscardUnknown(m)
}

var xxx_messageInfo_FioReadResult proto.InternalMessageInfo

func (m *FioReadResult) GetIops() float64 {
	if m != nil {
		return m.Iops
	}
	return 0
}

// FioWriteResult contains write-related metrics.
type FioWriteResult struct {
	// IOPS is the number of write iops.
	Iops                 float64  `protobuf:"fixed64,1,opt,name=iops,proto3" json:"iops"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FioWriteResult) Reset()         { *m = FioWriteResult{} }
func (m *FioWriteResult) String() string { return proto.CompactTextString(m) }
func (*FioWriteResult) ProtoMessage()    {}
func (*FioWriteResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{15}
}
func (m *FioWriteResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioWriteResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioWriteResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioWriteResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioWriteResult.Merge(m, src)
}
func (m *FioWriteResult) XXX_Size() int {
	return m.Size()
}
func (m *FioWriteResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FioWriteResult.DiscardUnknown(m)
}

var xxx_messageInfo_FioWriteResult proto.InternalMessageInfo

func (m *FioWriteResult) GetIops() float64 {
	if m != nil {
		return m.Iops
	}
	return 0
}

// FioSyncResult contains fsync-related metrics.
type FioSyncResult struct {
	// Latency contains fsync latencies distribution.
	Latency              *FioSyncLatency `protobuf:"bytes,1,opt,name=latency,proto3" json:"lat_ns"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FioSyncResult) Reset()         { *m = FioSyncResult{} }
func (m *FioSyncResult) String() string { return proto.CompactTextString(m) }
func (*FioSyncResult) ProtoMessage()    {}
func (*FioSyncResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{16}
}
func (m *FioSyncResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioSyncResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioSyncResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioSyncResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioSyncResult.Merge(m, src)
}
func (m *FioSyncResult) XXX_Size() int {
	return m.Size()
}
func (m *FioSyncResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FioSyncResult.DiscardUnknown(m)
}

var xxx_messageInfo_FioSyncResult proto.InternalMessageInfo

func (m *FioSyncResult) GetLatency() *FioSyncLatency {
	if m != nil {
		return m.Latency
	}
	return nil
}

// FioSyncLatency contains fsync latencies distribution.
type FioSyncLatency struct {
	// Percentile is the fsync percentile buckets.
	Percentile           map[string]int64 `protobuf:"bytes,1,rep,name=percentile,proto3" json:"percentile" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FioSyncLatency) Reset()         { *m = FioSyncLatency{} }
func (m *FioSyncLatency) String() string { return proto.CompactTextString(m) }
func (*FioSyncLatency) ProtoMessage()    {}
func (*FioSyncLatency) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfc2ab0b60b7792f, []int{17}
}
func (m *FioSyncLatency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FioSyncLatency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FioSyncLatency.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FioSyncLatency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FioSyncLatency.Merge(m, src)
}
func (m *FioSyncLatency) XXX_Size() int {
	return m.Size()
}
func (m *FioSyncLatency) XXX_DiscardUnknown() {
	xxx_messageInfo_FioSyncLatency.DiscardUnknown(m)
}

var xxx_messageInfo_FioSyncLatency proto.InternalMessageInfo

func (m *FioSyncLatency) GetPercentile() map[string]int64 {
	if m != nil {
		return m.Percentile
	}
	return nil
}

func init() {
	proto.RegisterType((*CheckPortsRequest)(nil), "proto.CheckPortsRequest")
	proto.RegisterType((*CheckPortsResponse)(nil), "proto.CheckPortsResponse")
	proto.RegisterType((*CheckBandwidthRequest)(nil), "proto.CheckBandwidthRequest")
	proto.RegisterType((*CheckBandwidthResponse)(nil), "proto.CheckBandwidthResponse")
	proto.RegisterType((*ServerResult)(nil), "proto.ServerResult")
	proto.RegisterType((*Addr)(nil), "proto.Addr")
	proto.RegisterType((*ValidateRequest)(nil), "proto.ValidateRequest")
	proto.RegisterType((*ValidateResponse)(nil), "proto.ValidateResponse")
	proto.RegisterType((*ValidateOptions)(nil), "proto.ValidateOptions")
	proto.RegisterType((*Docker)(nil), "proto.Docker")
	proto.RegisterType((*CheckDisksRequest)(nil), "proto.CheckDisksRequest")
	proto.RegisterType((*FioJobSpec)(nil), "proto.FioJobSpec")
	proto.RegisterType((*CheckDisksResponse)(nil), "proto.CheckDisksResponse")
	proto.RegisterType((*FioJobResult)(nil), "proto.FioJobResult")
	proto.RegisterType((*FioReadResult)(nil), "proto.FioReadResult")
	proto.RegisterType((*FioWriteResult)(nil), "proto.FioWriteResult")
	proto.RegisterType((*FioSyncResult)(nil), "proto.FioSyncResult")
	proto.RegisterType((*FioSyncLatency)(nil), "proto.FioSyncLatency")
	proto.RegisterMapType((map[string]int64)(nil), "proto.FioSyncLatency.PercentileEntry")
}

func init() { proto.RegisterFile("validation.proto", fileDescriptor_bfc2ab0b60b7792f) }

var fileDescriptor_bfc2ab0b60b7792f = []byte{
	// 1071 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x6e, 0x1c, 0x45,
	0x10, 0x66, 0xec, 0xfd, 0x2d, 0xc7, 0x8e, 0xdd, 0x8e, 0xc3, 0x7a, 0x71, 0xbc, 0xd6, 0x20, 0x27,
	0x96, 0xa2, 0xac, 0x91, 0x03, 0x11, 0x4a, 0x94, 0x43, 0x16, 0x87, 0x03, 0x0a, 0x60, 0xb5, 0x95,
	0x70, 0x42, 0xab, 0x99, 0x9d, 0xde, 0xdd, 0xf6, 0x8e, 0xbb, 0x27, 0x3d, 0xbd, 0x36, 0xce, 0x53,
	0x70, 0xe0, 0xc0, 0x89, 0x23, 0xcf, 0xc2, 0x05, 0x89, 0x13, 0x47, 0x0b, 0x99, 0x9b, 0x1f, 0x02,
	0xa1, 0xae, 0xee, 0xd9, 0x99, 0xb1, 0x8d, 0x72, 0xe3, 0xb2, 0xd3, 0x55, 0xf5, 0x55, 0xd7, 0x57,
	0x55, 0xdd, 0xd5, 0x0b, 0xcb, 0x27, 0x41, 0xcc, 0xa3, 0x40, 0x73, 0x29, 0xba, 0x89, 0x92, 0x5a,
	0x92, 0x2a, 0x7e, 0xda, 0x8f, 0x46, 0x5c, 0x8f, 0xa7, 0x61, 0x77, 0x20, 0x8f, 0x77, 0x47, 0x72,
	0x24, 0x77, 0x51, 0x1d, 0x4e, 0x87, 0x28, 0xa1, 0x80, 0x2b, 0xeb, 0xd5, 0xde, 0x1c, 0x49, 0x39,
	0x8a, 0x59, 0x8e, 0x8a, 0xa6, 0xaa, 0xb0, 0x6b, 0x7b, 0x35, 0x18, 0x31, 0xa1, 0x93, 0x70, 0x17,
	0xbf, 0x56, 0xe9, 0xff, 0xe8, 0xc1, 0xca, 0x17, 0x63, 0x36, 0x98, 0x1c, 0x48, 0xa5, 0x53, 0xca,
	0xde, 0x4e, 0x59, 0xaa, 0xc9, 0xc7, 0x50, 0x8b, 0x79, 0xaa, 0x99, 0x68, 0x79, 0x5b, 0xf3, 0x3b,
	0x0b, 0x7b, 0x0b, 0x16, 0xdd, 0x7d, 0x11, 0x45, 0x8a, 0x3a, 0x13, 0xe9, 0x40, 0x25, 0xe1, 0x62,
	0xd4, 0x9a, 0xbb, 0x0e, 0x41, 0x03, 0xf9, 0x0c, 0x1a, 0x19, 0x85, 0xd6, 0xfc, 0x96, 0xb7, 0xb3,
	0xb0, 0xb7, 0xde, 0xb5, 0x1c, 0xbb, 0x19, 0xc7, 0xee, 0xbe, 0x03, 0xd0, 0x19, 0xd4, 0x3f, 0x02,
	0x52, 0x64, 0x94, 0x26, 0x52, 0xa4, 0x8c, 0x3c, 0xbc, 0x42, 0x69, 0xd5, 0xc5, 0x3b, 0x64, 0xea,
	0x84, 0x29, 0xca, 0xd2, 0x69, 0xac, 0x67, 0xd4, 0x1e, 0x94, 0xa8, 0xdd, 0x08, 0x45, 0x80, 0xff,
	0x93, 0x07, 0x6b, 0x18, 0xac, 0x17, 0x88, 0xe8, 0x94, 0x47, 0x7a, 0x7c, 0x53, 0x09, 0xbc, 0xff,
	0xbb, 0x04, 0x4f, 0xe0, 0xee, 0x55, 0x56, 0xae, 0x0c, 0x1b, 0xd0, 0x0c, 0x33, 0x25, 0x32, 0xab,
	0xd0, 0x5c, 0xe1, 0x7f, 0x0f, 0xb7, 0x8a, 0x49, 0x12, 0x02, 0x95, 0x81, 0x8c, 0x18, 0x02, 0xab,
	0x14, 0xd7, 0xe4, 0x0e, 0x54, 0x99, 0x52, 0x52, 0xb5, 0xe6, 0xb6, 0xbc, 0x9d, 0x26, 0xb5, 0x82,
	0x49, 0x37, 0x45, 0x4f, 0x47, 0xb3, 0x9c, 0xae, 0x35, 0xf9, 0x9f, 0x42, 0xc5, 0xc8, 0xa4, 0x05,
	0x75, 0xc1, 0xf4, 0xa9, 0x54, 0x13, 0xdc, 0xb9, 0x49, 0x33, 0xd1, 0x04, 0x0c, 0xa2, 0x28, 0xdb,
	0x1b, 0xd7, 0xfe, 0xef, 0x1e, 0xdc, 0x7e, 0x63, 0x8f, 0x38, 0xcb, 0xaa, 0xdb, 0x86, 0xc6, 0x71,
	0x20, 0xf8, 0x90, 0xa5, 0x1a, 0xb7, 0xb8, 0x45, 0x67, 0xb2, 0xd9, 0x3d, 0x51, 0x72, 0xc8, 0x63,
	0xe6, 0xb6, 0xc9, 0x44, 0xf2, 0x10, 0x56, 0x86, 0xd3, 0x38, 0xee, 0x2b, 0xf6, 0x76, 0xca, 0x15,
	0x3b, 0x66, 0x42, 0xa7, 0xc8, 0xb7, 0x41, 0x97, 0x8d, 0x81, 0x16, 0xf4, 0xe4, 0x13, 0xa8, 0xcb,
	0xc4, 0x54, 0x33, 0x6d, 0x55, 0x30, 0xa5, 0xbb, 0x2e, 0xa5, 0x8c, 0xcb, 0xb7, 0xd6, 0x4a, 0x33,
	0x18, 0xd9, 0x86, 0x5a, 0x24, 0x07, 0x13, 0xa6, 0x5a, 0x55, 0x74, 0x58, 0x74, 0x0e, 0xfb, 0xa8,
	0xa4, 0xce, 0xe8, 0x3f, 0x85, 0xe5, 0x3c, 0x1d, 0xd7, 0x96, 0xfb, 0x50, 0x1b, 0x06, 0x3c, 0x66,
	0x91, 0x3b, 0x9d, 0x4b, 0x5d, 0x77, 0xd9, 0xba, 0x07, 0x4a, 0x86, 0x8c, 0x3a, 0xab, 0x3f, 0xce,
	0x4b, 0xe1, 0xc2, 0x93, 0x7b, 0x00, 0x27, 0x3f, 0xc4, 0x81, 0xe8, 0x27, 0x52, 0x69, 0xd7, 0xa9,
	0x26, 0x6a, 0xcc, 0x05, 0x20, 0x1f, 0x41, 0x33, 0x12, 0x69, 0xdf, 0x54, 0x32, 0xc5, 0x73, 0xd6,
	0xa4, 0x8d, 0x48, 0xa4, 0xa6, 0x0f, 0x29, 0x59, 0x07, 0xb3, 0xb6, 0x9e, 0xf3, 0xe8, 0x59, 0x8f,
	0x44, 0x6a, 0xfc, 0xfc, 0x5d, 0xa8, 0x59, 0xde, 0x64, 0x1b, 0x96, 0x52, 0x2d, 0x55, 0x30, 0x62,
	0xfd, 0x48, 0x71, 0xd3, 0x62, 0xdb, 0xb4, 0x45, 0xa7, 0xdd, 0x47, 0xa5, 0xff, 0xda, 0x0d, 0x82,
	0x7d, 0x9e, 0x4e, 0x66, 0x83, 0x60, 0x1b, 0x2a, 0x47, 0x32, 0x4c, 0x5d, 0x56, 0x2b, 0xae, 0x20,
	0x5f, 0x72, 0xf9, 0x95, 0x0c, 0x0f, 0x13, 0x36, 0xa0, 0x68, 0x36, 0x3c, 0x86, 0x5c, 0xf6, 0x93,
	0x40, 0x8f, 0xb3, 0x9e, 0x0d, 0xb9, 0x3c, 0x08, 0xf4, 0xd8, 0xff, 0xc7, 0x03, 0xc8, 0xf1, 0xe6,
	0x80, 0x88, 0xe0, 0x98, 0x39, 0x0a, 0xb8, 0x36, 0x15, 0x50, 0x2c, 0x88, 0xfa, 0xa7, 0x8a, 0xeb,
	0xac, 0xe7, 0x4d, 0xa3, 0xf9, 0xce, 0x28, 0x4c, 0x05, 0xb8, 0xec, 0x33, 0x31, 0xe2, 0x82, 0x61,
	0x96, 0x4d, 0xda, 0xe0, 0xf2, 0x25, 0xca, 0xe6, 0x3e, 0x0c, 0xa3, 0x40, 0x07, 0xe9, 0x99, 0x18,
	0x60, 0x9f, 0x1b, 0x34, 0x57, 0x98, 0x63, 0x66, 0x0e, 0x0e, 0x46, 0xac, 0x5a, 0xcf, 0x4c, 0x36,
	0x51, 0xc3, 0x58, 0x0e, 0x26, 0xfd, 0x94, 0xbf, 0x63, 0xad, 0x9a, 0x8d, 0x8a, 0x9a, 0x43, 0xfe,
	0x8e, 0x19, 0xa2, 0x68, 0xa8, 0x5b, 0xa2, 0x66, 0x4d, 0x1e, 0x43, 0x5d, 0x4d, 0x85, 0xe6, 0xc7,
	0xac, 0xd5, 0x78, 0xdf, 0x65, 0xce, 0x90, 0xfe, 0x73, 0x37, 0xce, 0x5c, 0x5d, 0xdd, 0x81, 0x79,
	0x50, 0x2a, 0xec, 0x6a, 0xa9, 0xb0, 0xd9, 0x84, 0x32, 0x00, 0xff, 0x4f, 0x0f, 0x6e, 0x15, 0xd5,
	0xe4, 0x3e, 0x34, 0x8e, 0x64, 0xd8, 0xcf, 0xab, 0xd8, 0x5b, 0xb8, 0x3c, 0xef, 0xd4, 0x8f, 0x64,
	0x68, 0x54, 0xd4, 0x2c, 0xbe, 0x31, 0xf9, 0xed, 0x41, 0xc5, 0xd4, 0x10, 0xeb, 0xb9, 0xb0, 0x77,
	0x27, 0x8f, 0x40, 0x59, 0x10, 0xd9, 0xbd, 0x7a, 0x8d, 0xcb, 0xf3, 0x0e, 0xa2, 0x28, 0xfe, 0x92,
	0x27, 0x50, 0xb5, 0x4d, 0xb0, 0x43, 0x60, 0x2d, 0x77, 0xc2, 0x56, 0x38, 0xaf, 0xe6, 0xe5, 0x79,
	0xc7, 0xe2, 0xa8, 0xfd, 0x98, 0x58, 0xb3, 0x06, 0x94, 0x62, 0x1d, 0x9e, 0x89, 0x41, 0x31, 0x96,
	0x41, 0x51, 0xfc, 0xf5, 0x1f, 0xc1, 0x62, 0x89, 0x0c, 0xd9, 0x80, 0x0a, 0x97, 0x49, 0x8a, 0x49,
	0x79, 0x16, 0x6e, 0x64, 0x8a, 0xbf, 0x7e, 0x17, 0x96, 0xca, 0x34, 0xde, 0x83, 0x7f, 0x85, 0xdb,
	0xe7, 0xf1, 0xc9, 0x33, 0xa8, 0xc7, 0x81, 0x66, 0x62, 0x70, 0xe6, 0x26, 0xfa, 0x5a, 0x99, 0xe6,
	0x2b, 0x6b, 0xec, 0xc1, 0xe5, 0x79, 0xa7, 0x16, 0x07, 0xba, 0x6f, 0x46, 0x83, 0xf3, 0xf0, 0x7f,
	0xf5, 0x30, 0x7c, 0x01, 0x47, 0x5e, 0x03, 0x24, 0x4c, 0x0d, 0x98, 0xd0, 0x66, 0x52, 0xd9, 0x3e,
	0x6e, 0xdf, 0xb8, 0x65, 0xf7, 0x60, 0x86, 0x7b, 0x29, 0xb4, 0x3a, 0xeb, 0x2d, 0x5d, 0x9e, 0x77,
	0x0a, 0xce, 0xb4, 0xb0, 0x6e, 0x3f, 0x87, 0xdb, 0x57, 0xe0, 0x64, 0x19, 0xe6, 0x27, 0xec, 0xcc,
	0x5d, 0x19, 0xb3, 0x34, 0x33, 0xfc, 0x24, 0x88, 0xa7, 0xf6, 0xb2, 0xcc, 0x53, 0x2b, 0x3c, 0x9d,
	0xfb, 0xdc, 0xdb, 0xfb, 0x65, 0x0e, 0xe0, 0xcd, 0xec, 0xff, 0x04, 0x79, 0x01, 0x90, 0xbf, 0xa5,
	0xa4, 0xe5, 0xe8, 0x5d, 0x7b, 0xf0, 0xdb, 0xeb, 0x37, 0x58, 0xdc, 0x49, 0xfd, 0x1a, 0x96, 0xca,
	0x6f, 0x11, 0xd9, 0x28, 0x82, 0xaf, 0x3e, 0x9c, 0xed, 0x7b, 0xff, 0x61, 0x75, 0xdb, 0x65, 0x8c,
	0xf0, 0x3a, 0x94, 0x19, 0x15, 0x27, 0x4f, 0x99, 0x51, 0xf9, 0xee, 0x3c, 0x83, 0x46, 0x36, 0x44,
	0xc9, 0xd5, 0xa1, 0x9e, 0xb9, 0x7f, 0x78, 0x4d, 0x6f, 0x9d, 0x7b, 0xcb, 0xbf, 0x5d, 0x6c, 0x7a,
	0x7f, 0x5c, 0x6c, 0x7a, 0x7f, 0x5d, 0x6c, 0x7a, 0x3f, 0xff, 0xbd, 0xf9, 0x41, 0x58, 0x43, 0xe4,
	0xe3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xe2, 0xbe, 0xcb, 0xf1, 0x88, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ValidationClient is the client API for Validation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ValidationClient interface {
	// CheckPorts executes a ports network test
	CheckPorts(ctx context.Context, in *CheckPortsRequest, opts ...grpc.CallOption) (*CheckPortsResponse, error)
	// CheckBandwidth executes a bandwidth network test
	CheckBandwidth(ctx context.Context, in *CheckBandwidthRequest, opts ...grpc.CallOption) (*CheckBandwidthResponse, error)
	// CheckDisks executes performance test for the specified disks
	CheckDisks(ctx context.Context, in *CheckDisksRequest, opts ...grpc.CallOption) (*CheckDisksResponse, error)
	// Validate validatest this node against the requirements
	// from a manifest.
	Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
}

type validationClient struct {
	cc *grpc.ClientConn
}

func NewValidationClient(cc *grpc.ClientConn) ValidationClient {
	return &validationClient{cc}
}

func (c *validationClient) CheckPorts(ctx context.Context, in *CheckPortsRequest, opts ...grpc.CallOption) (*CheckPortsResponse, error) {
	out := new(CheckPortsResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckPorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) CheckBandwidth(ctx context.Context, in *CheckBandwidthRequest, opts ...grpc.CallOption) (*CheckBandwidthResponse, error) {
	out := new(CheckBandwidthResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckBandwidth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) CheckDisks(ctx context.Context, in *CheckDisksRequest, opts ...grpc.CallOption) (*CheckDisksResponse, error) {
	out := new(CheckDisksResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/CheckDisks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationClient) Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, "/proto.Validation/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidationServer is the server API for Validation service.
type ValidationServer interface {
	// CheckPorts executes a ports network test
	CheckPorts(context.Context, *CheckPortsRequest) (*CheckPortsResponse, error)
	// CheckBandwidth executes a bandwidth network test
	CheckBandwidth(context.Context, *CheckBandwidthRequest) (*CheckBandwidthResponse, error)
	// CheckDisks executes performance test for the specified disks
	CheckDisks(context.Context, *CheckDisksRequest) (*CheckDisksResponse, error)
	// Validate validatest this node against the requirements
	// from a manifest.
	Validate(context.Context, *ValidateRequest) (*ValidateResponse, error)
}

func RegisterValidationServer(s *grpc.Server, srv ValidationServer) {
	s.RegisterService(&_Validation_serviceDesc, srv)
}

func _Validation_CheckPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckPortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckPorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckPorts(ctx, req.(*CheckPortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_CheckBandwidth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBandwidthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckBandwidth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckBandwidth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckBandwidth(ctx, req.(*CheckBandwidthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_CheckDisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).CheckDisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/CheckDisks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).CheckDisks(ctx, req.(*CheckDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Validation_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Validation/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationServer).Validate(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Validation_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Validation",
	HandlerType: (*ValidationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckPorts",
			Handler:    _Validation_CheckPorts_Handler,
		},
		{
			MethodName: "CheckBandwidth",
			Handler:    _Validation_CheckBandwidth_Handler,
		},
		{
			MethodName: "CheckDisks",
			Handler:    _Validation_CheckDisks_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _Validation_Validate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "validation.proto",
}

func (m *CheckPortsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPortsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, msg := range m.Listen {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Duration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Duration.Size()))
		n1, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckPortsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPortsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, msg := range m.Listen {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckBandwidthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBandwidthRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Listen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Listen.Size()))
		n2, err := m.Listen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Ping) > 0 {
		for _, msg := range m.Ping {
			dAtA[i] = 0x12
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Duration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Duration.Size()))
		n3, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckBandwidthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBandwidthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bandwidth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Bandwidth))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Code))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Server != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Server.Size()))
		n4, err := m.Server.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Network) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Manifest) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Manifest)))
		i += copy(dAtA[i:], m.Manifest)
	}
	if len(m.Profile) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Profile)))
		i += copy(dAtA[i:], m.Profile)
	}
	if m.FullRequirements {
		dAtA[i] = 0x18
		i++
		if m.FullRequirements {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Options != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Options.Size()))
		n5, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Docker != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Docker.Size()))
		n6, err := m.Docker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Failed) > 0 {
		for _, msg := range m.Failed {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VxlanPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.VxlanPort))
	}
	if len(m.DnsAddrs) > 0 {
		for _, s := range m.DnsAddrs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DnsPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.DnsPort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Docker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Docker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageDriver) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.StorageDriver)))
		i += copy(dAtA[i:], m.StorageDriver)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckDisksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDisksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FioPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.FioPath)))
		i += copy(dAtA[i:], m.FioPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioJobSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioJobSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ReadWrite) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.ReadWrite)))
		i += copy(dAtA[i:], m.ReadWrite)
	}
	if len(m.IoEngine) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.IoEngine)))
		i += copy(dAtA[i:], m.IoEngine)
	}
	if m.Fdatasync {
		dAtA[i] = 0x20
		i++
		if m.Fdatasync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Filename) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Filename)))
		i += copy(dAtA[i:], m.Filename)
	}
	if len(m.BlockSize) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.BlockSize)))
		i += copy(dAtA[i:], m.BlockSize)
	}
	if len(m.Size_) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.Size_)))
		i += copy(dAtA[i:], m.Size_)
	}
	if m.Runtime != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Runtime.Size()))
		n7, err := m.Runtime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckDisksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDisksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioJobResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioJobResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(len(m.JobName)))
		i += copy(dAtA[i:], m.JobName)
	}
	if m.Read != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Read.Size()))
		n8, err := m.Read.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Write != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Write.Size()))
		n9, err := m.Write.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Sync != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Sync.Size()))
		n10, err := m.Sync.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioReadResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioReadResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Iops != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Iops))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioWriteResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioWriteResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Iops != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Iops))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioSyncResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioSyncResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Latency != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintValidation(dAtA, i, uint64(m.Latency.Size()))
		n11, err := m.Latency.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FioSyncLatency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FioSyncLatency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Percentile) > 0 {
		for k, _ := range m.Percentile {
			dAtA[i] = 0xa
			i++
			v := m.Percentile[k]
			mapSize := 1 + len(k) + sovValidation(uint64(len(k))) + 1 + sovValidation(uint64(v))
			i = encodeVarintValidation(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintValidation(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintValidation(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintValidation(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CheckPortsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, e := range m.Listen {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckPortsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Listen) > 0 {
		for _, e := range m.Listen {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckBandwidthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Listen != nil {
		l = m.Listen.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if len(m.Ping) > 0 {
		for _, e := range m.Ping {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckBandwidthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth != 0 {
		n += 1 + sovValidation(uint64(m.Bandwidth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovValidation(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.FullRequirements {
		n += 2
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Docker != nil {
		l = m.Docker.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Failed) > 0 {
		for _, e := range m.Failed {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VxlanPort != 0 {
		n += 1 + sovValidation(uint64(m.VxlanPort))
	}
	if len(m.DnsAddrs) > 0 {
		for _, s := range m.DnsAddrs {
			l = len(s)
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.DnsPort != 0 {
		n += 1 + sovValidation(uint64(m.DnsPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Docker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StorageDriver)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDisksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	l = len(m.FioPath)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioJobSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.ReadWrite)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.IoEngine)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Fdatasync {
		n += 2
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.BlockSize)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDisksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovValidation(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioJobResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Read != nil {
		l = m.Read.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Write != nil {
		l = m.Write.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.Sync != nil {
		l = m.Sync.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioReadResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Iops != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioWriteResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Iops != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioSyncResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latency != nil {
		l = m.Latency.Size()
		n += 1 + l + sovValidation(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FioSyncLatency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Percentile) > 0 {
		for k, v := range m.Percentile {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovValidation(uint64(len(k))) + 1 + sovValidation(uint64(v))
			n += mapEntrySize + 1 + sovValidation(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovValidation(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozValidation(x uint64) (n int) {
	return sovValidation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CheckPortsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPortsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPortsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listen = append(m.Listen, &Addr{})
			if err := m.Listen[len(m.Listen)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &Addr{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPortsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPortsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPortsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Listen = append(m.Listen, &ServerResult{})
			if err := m.Listen[len(m.Listen)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &ServerResult{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBandwidthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBandwidthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBandwidthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Listen == nil {
				m.Listen = &Addr{}
			}
			if err := m.Listen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ping = append(m.Ping, &Addr{})
			if err := m.Ping[len(m.Ping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBandwidthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBandwidthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBandwidthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth", wireType)
			}
			m.Bandwidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bandwidth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &Addr{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = append(m.Manifest[:0], dAtA[iNdEx:postIndex]...)
			if m.Manifest == nil {
				m.Manifest = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullRequirements", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullRequirements = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ValidateOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Docker == nil {
				m.Docker = &Docker{}
			}
			if err := m.Docker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failed = append(m.Failed, &agentpb.Probe{})
			if err := m.Failed[len(m.Failed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanPort", wireType)
			}
			m.VxlanPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VxlanPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsAddrs = append(m.DnsAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsPort", wireType)
			}
			m.DnsPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Docker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Docker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Docker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageDriver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDisksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDisksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDisksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &FioJobSpec{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FioPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FioPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioJobSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioJobSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioJobSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWrite", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadWrite = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoEngine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IoEngine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fdatasync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fdatasync = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &types.Duration{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDisksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDisksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDisksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &FioJobResult{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioJobResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioJobResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioJobResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Read == nil {
				m.Read = &FioReadResult{}
			}
			if err := m.Read.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Write == nil {
				m.Write = &FioWriteResult{}
			}
			if err := m.Write.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sync", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sync == nil {
				m.Sync = &FioSyncResult{}
			}
			if err := m.Sync.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioReadResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioReadResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioReadResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iops", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Iops = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioWriteResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioWriteResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioWriteResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iops", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Iops = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioSyncResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioSyncResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioSyncResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latency == nil {
				m.Latency = &FioSyncLatency{}
			}
			if err := m.Latency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FioSyncLatency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FioSyncLatency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FioSyncLatency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthValidation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthValidation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Percentile == nil {
				m.Percentile = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowValidation
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValidation
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthValidation
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthValidation
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowValidation
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipValidation(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthValidation
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Percentile[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipValidation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthValidation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipValidation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowValidation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowValidation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthValidation
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthValidation
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowValidation
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipValidation(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthValidation
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthValidation = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowValidation   = fmt.Errorf("proto: integer overflow")
)
